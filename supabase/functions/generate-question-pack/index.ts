import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { serverClient } from "../_shared/client.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabase = serverClient(req);
    const { microSlug } = await req.json();

    if (!microSlug) {
      throw new Error("microSlug is required");
    }

    console.log(`[generate-question-pack] Starting generation for: ${microSlug}`);

    // 1. Fetch micro-service details
    const { data: micro, error: microError } = await supabase
      .from('service_micro_categories')
      .select(`
        slug, name, description,
        service_subcategories (
          name,
          service_categories (name, slug)
        )
      `)
      .eq('slug', microSlug)
      .single();

    if (microError || !micro) {
      console.error('[generate-question-pack] Micro not found:', microError);
      throw new Error(`Micro-service not found: ${microSlug}`);
    }

    const categoryName = (micro.service_subcategories as any)?.service_categories?.name || 'Unknown';
    const categorySlug = (micro.service_subcategories as any)?.service_categories?.slug || 'unknown';
    const subcategoryName = (micro.service_subcategories as any)?.name || 'Unknown';

    console.log(`[generate-question-pack] Context: ${categoryName} > ${subcategoryName} > ${micro.name}`);

    // 2. Fetch example packs from same category for pattern learning
    const { data: examples } = await supabase
      .from('question_packs')
      .select('content, micro_slug')
      .eq('status', 'approved')
      .eq('is_active', true)
      .limit(3);

    const exampleContent = examples?.map(ex => ex.content).filter(Boolean) || [];
    
    console.log(`[generate-question-pack] Found ${exampleContent.length} example packs`);

    // 3. Build AI prompt
    const prompt = buildPrompt(micro, categoryName, categorySlug, subcategoryName, exampleContent);

    // 4. Call Lovable AI
    console.log('[generate-question-pack] Calling Lovable AI...');
    
    const aiResponse = await fetch("https://ai.gateway.lovable.dev/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${Deno.env.get("LOVABLE_API_KEY")}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: "google/gemini-2.5-flash",
        messages: [
          {
            role: "system",
            content: "You are an expert at creating professional service question packs. Generate structured, contextual questions that help clients accurately describe their service needs. Always return valid JSON matching the specified schema."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        temperature: 0.7,
        max_tokens: 2000,
      }),
    });

    if (!aiResponse.ok) {
      const errorText = await aiResponse.text();
      console.error('[generate-question-pack] AI API error:', errorText);
      throw new Error(`AI generation failed: ${aiResponse.statusText}`);
    }

    const aiData = await aiResponse.json();
    const generatedText = aiData.choices?.[0]?.message?.content;

    if (!generatedText) {
      throw new Error("No content generated by AI");
    }

    console.log('[generate-question-pack] AI response received, parsing...');

    // 5. Parse and validate JSON
    const generatedPack = parseAIResponse(generatedText);
    
    // 6. Validate pack structure
    validatePack(generatedPack);

    console.log('[generate-question-pack] Pack generated successfully');

    return new Response(
      JSON.stringify({ pack: generatedPack }),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );

  } catch (error: any) {
    console.error('[generate-question-pack] Error:', error);
    return new Response(
      JSON.stringify({ 
        error: error?.message || "Pack generation failed",
        details: error?.toString() || "Unknown error"
      }),
      { 
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" }
      }
    );
  }
});

function buildPrompt(
  micro: any,
  categoryName: string,
  categorySlug: string,
  subcategoryName: string,
  examples: any[]
): string {
  const examplesText = examples.length > 0
    ? `Here are ${examples.length} examples of approved question packs to learn the pattern from:\n\n${examples.map((ex, i) => `Example ${i + 1}:\n${JSON.stringify(ex, null, 2)}`).join('\n\n')}\n\n`
    : '';

  return `${examplesText}Now create a question pack for this new micro-service:

**Micro-service Details:**
- Name: ${micro.name}
- Slug: ${micro.slug}
- Category: ${categoryName} (${categorySlug})
- Subcategory: ${subcategoryName}
- Description: ${micro.description || 'No description provided'}

**Requirements:**
1. Generate 8-12 contextual questions specific to "${micro.name}"
2. Use appropriate question types: "single", "multi", "scale", "text", "yesno", "number"
3. Include i18n keys in format: "microservices.${categorySlug}.${micro.slug}.questions.{key}"
4. Make key questions "required: true"
5. Add "aiHint" to each question (brief guidance for AI processing)
6. Include "options" array for single/multi choice questions
7. Use "visibility" rules sparingly (only when a question depends on another)

**Return ONLY valid JSON** in this exact structure (no markdown, no code blocks):

{
  "id": "${micro.slug}-pack",
  "category": "${categorySlug}",
  "name": "${micro.name}",
  "slug": "${micro.slug}",
  "i18nPrefix": "microservices.${categorySlug}.${micro.slug}",
  "questions": [
    {
      "key": "question_key",
      "type": "single",
      "i18nKey": "microservices.${categorySlug}.${micro.slug}.questions.question_key",
      "required": true,
      "options": [
        { "value": "option1", "label": "Option 1" },
        { "value": "option2", "label": "Option 2" }
      ],
      "aiHint": "Brief hint for AI about what this question determines"
    }
  ]
}

Generate the complete JSON now:`;
}

function parseAIResponse(text: string): any {
  // Remove markdown code blocks if present
  let cleaned = text.trim();
  if (cleaned.startsWith('```')) {
    cleaned = cleaned.replace(/^```(?:json)?\n/, '').replace(/\n```$/, '');
  }

  try {
    return JSON.parse(cleaned);
  } catch (e: any) {
    console.error('[parseAIResponse] Failed to parse:', cleaned.substring(0, 200));
    throw new Error(`Invalid JSON from AI: ${e?.message || 'Parse error'}`);
  }
}

function validatePack(pack: any): void {
  if (!pack.id || !pack.slug || !pack.name || !pack.category) {
    throw new Error("Pack missing required fields (id, slug, name, category)");
  }

  if (!Array.isArray(pack.questions) || pack.questions.length === 0) {
    throw new Error("Pack must have at least one question");
  }

  for (const q of pack.questions) {
    if (!q.key || !q.type || !q.i18nKey) {
      throw new Error(`Question missing required fields: ${JSON.stringify(q)}`);
    }

    const validTypes = ['single', 'multi', 'scale', 'text', 'yesno', 'number'];
    if (!validTypes.includes(q.type)) {
      throw new Error(`Invalid question type: ${q.type}`);
    }

    if ((q.type === 'single' || q.type === 'multi') && !Array.isArray(q.options)) {
      throw new Error(`Question type ${q.type} requires options array`);
    }
  }
}
